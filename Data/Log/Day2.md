# 文件说明

* 文件创建时间：2020年04月10日
* 最后修改时间：2020年04月10日
* 文件主要内容：操作日志、私聊功能实现、问题分析及解决方案

## 操作日志

* 实现的功能

1. 实现了使用用户名标识的私聊功能
2. 优化了客户端显示的内容
3. 录制了测试视频

## Bug集中营

### 一、关于用户名的问题

昨天已经实现了群聊和私聊的功能，但是在私聊时需要输入对方客户端的PID识别号，很不方便。目前的想到的解决方法是：在每一个客户端启动时，首先要求用户输入它的用户名，私聊时以用户名作为客户端的标识。

* 问题关键

如果使用用户名作为标识的话，需要在客户端发送的结构体数据中，添加用户名的成员变量。在私聊时，将数据分割方式由分割PID换成分割用户名。这样其实会简单一些，因为不用再去判断PID和消息内容了。<br>
调了一会，现在功能已经实现了。这部分的功能实现，因为与之前的思路（用客户端PID作为标识）有不同的地方，所以修改起来还是比较麻烦的，修改的代码比较多。

* 解决方案

1. 客户端启动之后，就要求用户输入用户名。该用户名被保存在客户端的结构体成员变量中，发给服务器。
2. 在客户端进行数据的过滤，如果是私发信息，就将私发对象的用户名和要私发的信息拆分开来，分别存储到结构体成员变量中。如果不是私发信息，就在相应的结构体变量中添加标识。
3. 服务器收到客户端的结构体数据之后，将该客户端的PID和用户名，分别保存在两个数组中。
4. 服务器通过检测结构体中的target_name，来判断是否该数据需要私发。如果需要私发，就执行私发代码；否则执行循环发送代码。
5. 私发的情况下，服务器首先需要在用户名数组中，循环查找一下是否存在该用户。如果存在该用户，那么可以向对方发送消息，同时获取该用户在用户结构体中的坐标（它是第几个用户）。根据这个目标用户的坐标，就可以找到与它对应的PID，进而可以打开私有管道，只对其私发信息。
6. 同样，通过在用户PID数组中循环查找发送消息的用户位置，可以找到与其对应的用户名。进而可以知道，是那个用户发出的消息。

> PS: 我自认为在解决该问题中，比较巧妙地用到了 **用户名数组和用户PID数组的下标一致性** 这样的特点。

### 关于客户端界面的问题

#### 时间显示问题

本来是想用QT做一个界面，但估计我短时间做不出来。。。<br>
那就先把客户端的终端界面搞一搞。模仿QQ的聊天室界面，在用户输入消息之后，需要在每个消息之前加上信息发送的时间。

* 问题分析

> 给客户端的每条消息加上时间，也有两种解决方式。

1. 客户端自己将时间信息加到消息结构体中，用结构体成员保存时间信息。
2. 由服务器加上时间前缀。服务器回复每条消息前，都在信息前面加上当前时间作为消息前缀。

* 解决方式

经过我的测试，发现QQ是由服务器统一显示的时间，大概是为了统一信息接收时间。但是我想要减轻一下服务器的负担，所以就由客户端自身写入当前时间。<br>
时间的显示比较容易，直接调用库函数就可以了。

#### 握手消息问题

* 问题分析

每个客户端在启动之后，首先就会向服务器发送一个握手消息，以便服务器为其创建私有管道。但是现在每次的握手消息会被发送至所有客户端，只显示握手消息的内容的话不太友好。所以需要改变一下握手信息的显示方式。

* 解决方式

处理方式也很简单，就是在每次服务器群发数据之前，都事先判断一下当前的客户端是不是新来的客户端。如果是新的客户端，就改变消息发送的内容。